import { ConnectButton } from "@rainbow-me/rainbowkit";
import Button from "@mui/material/Button";
import type { NextPage } from "next";
import Head from "next/head";
import styles from "../styles/Home.module.css";
import { useAccount } from "wagmi";
import {
  superfluidABI,
  superTokenPoolABI,
  useGdAv1IsMemberConnected,
  usePrepareSuperfluidCallAgreement,
  useSuperfluidCallAgreement,
  useSuperTokenPoolAdmin,
  useSuperTokenPoolGetMemberFlowRate,
  useSuperTokenPoolSuperToken,
} from "../src/generated";
import { ethers } from "ethers";
import {
  Card,
  CardContent,
  Link,
  Paper,
  Tab,
  Tabs,
  Typography,
} from "@mui/material";
import { useMemo, useState } from "react";
import { Interface } from "@ethersproject/abi";
import EntryPoint from "./EntryPoint";
import TabPanel from "../component/TabPanel";
import { gdaContract } from "../src/constants";
import PoolInfoCard from "../component/PoolInfo";

enum TabType {
  Distributor,
  Member,
}

const superfluidContract = {
  superfluidABI,
  address: "0x61df7e94415b632d191bcd2106645ce8aeb38e33" as any,
};
const GDA_INTERFACE = new Interface([
  "function connectPool(address,bytes calldata) returns(bytes memory)",
  "function disconnectPool(address,bytes calldata) returns(bytes memory)",
]);

const Home: NextPage = () => {
  const { address } = useAccount();
  const [tab, setTab] = useState(TabType.Distributor);
  const [existingPools, setExistingPools] = useState<string[]>([
    "0xfbd3363e2fc4db7ce069dd422a54cc5c5eaca9b7",
    "0xfajdj",
    "0xjllas",
  ]);
  // useEffect if existingPools.length > 0, setEntryPoint to SelectPool
  const [currentPool, setCurrentPool] = useState("");

  const poolContract = {
    superTokenPoolABI,
    address: currentPool as any,
  };

  // HOOKS
  // REACT HOOKS
  const currentTime = useMemo(() => {
    return Math.round(new Date().getTime() / 1000);
  }, []);

  // READ HOOKS

  // READ HOOKS
  // SUPERTOKENPOOL
  const { data: poolAdmin, isFetchedAfterMount: poolAdminLoaded } =
    useSuperTokenPoolAdmin({
      ...poolContract,
      enabled: ethers.utils.isAddress(currentPool),
    });

  const {
    data: superTokenAddress,
    isFetchedAfterMount: superTokenAddressLoaded,
  } = useSuperTokenPoolSuperToken({
    ...poolContract,
    enabled: ethers.utils.isAddress(currentPool),
  });

  const isAdmin = useMemo(() => address === poolAdmin, [address, poolAdmin]);

  const {
    data: poolMemberFlowRate,
    isFetchedAfterMount: poolMemberFlowRateLoaded,
  } = useSuperTokenPoolGetMemberFlowRate({
    ...poolContract,
    args: [address as any],
    watch: true,
    enabled: address != null,
  });
  const {
    data: isMemberConnected,
    isFetchedAfterMount: isMemberConnectedLoaded,
  } = useGdAv1IsMemberConnected({
    ...gdaContract,
    args: [superTokenAddress as any, poolContract.address, address as any],
    watch: true,
    enabled: address != null,
  });

  // WRITE HOOKS
  // Call Agreement Write Hook

  console.log(poolContract.address);
  console.log(superfluidContract.address);
  // SUPERFLUID
  const { config: connectPoolConfig } = usePrepareSuperfluidCallAgreement({
    ...superfluidContract,
    args: [
      gdaContract.address,
      currentPool === ""
        ? "0x"
        : (GDA_INTERFACE.encodeFunctionData("connectPool", [
          currentPool,
          "0x",
        ]) as any),
      "0x",
    ],
    enabled: currentPool !== "",
  });
  const { config: disconnectPoolConfig } = usePrepareSuperfluidCallAgreement({
    ...superfluidContract,
    args: [
      gdaContract.address,
      currentPool === ""
        ? "0x"
        : (GDA_INTERFACE.encodeFunctionData("disconnectPool", [
          currentPool,
          "0x",
        ]) as any),
      "0x",
    ],
    enabled: currentPool !== "",
  });

  const { writeAsync: connectPoolWrite } =
    useSuperfluidCallAgreement(connectPoolConfig);
  const { writeAsync: disconnectPoolWrite } =
    useSuperfluidCallAgreement(disconnectPoolConfig);

  const connectPool = async () => {
    if (!connectPoolWrite) return;
    try {
      await connectPoolWrite();
    } catch (err) {
      console.error(err);
    }
  };

  const disconnectPool = async () => {
    if (!disconnectPoolWrite) return;
    try {
      await disconnectPoolWrite();
    } catch (err) {
      console.error(err);
    }
  };

  return (
    <Paper>
      <Head>
        <title>GDA Testnet Demo</title>
        <meta
          content="Generated by @rainbow-me/create-rainbowkit"
          name="description"
        />
        <link href="/favicon.ico" rel="icon" />
      </Head>

      <Paper className={styles.main}>
        <ConnectButton />
        {currentPool === "" && <>
          <Typography variant="h1" className={styles.title}>
            GDA Testnet Demo
          </Typography>
          <Card elevation={3} style={{ maxWidth: "690px" }}>
            <CardContent>
              <Typography variant="h3" color="red">
                IMPORTANT! PLEASE READ
              </Typography>
              <Typography variant="subtitle1">
                Welcome! This is a demo of the General Distribution Agreement.
              </Typography>
              <Typography variant="subtitle1">
                Note that it is an alpha release in development and is not ready
                for production use and it is possible you encounter some issues.
                Please{" "}
                <Link href="https://github.com/superfluid-finance/protocol-monorepo/issues/new?assignees=&labels=Type%3A+Bug&template=general-bug-report.md&title=%5BBUG%5D+">
                  submit any issues
                </Link>{" "}
                you find to our GitHub or hop into our Discord to report it.
              </Typography>
            </CardContent>
          </Card>
        </>}

        {currentPool === "" && (
          <EntryPoint
            existingPools={existingPools}
            currentPool={currentPool}
            setCurrentPool={(x) => setCurrentPool(x)}
          />
        )}

        {currentPool !== "" && (
          <div>
            <PoolInfoCard
              poolAddress={currentPool}
              poolAdmin={poolAdminLoaded && poolAdmin ? poolAdmin : ""}
              superTokenAddress={
                superTokenAddressLoaded && superTokenAddress
                  ? superTokenAddress
                  : ""
              }
            />

            <Tabs value={tab} onChange={(_x, v) => setTab(v)}>
              <Tab label="Pool Admin/Distributor" />
              <Tab label="Member" />
            </Tabs>

            <TabPanel value={tab} index={0}>
              <p>Distributor</p>
            </TabPanel>
            <TabPanel value={tab} index={1}>
              <div>
                {!isMemberConnected && (
                  <Button
                    variant="contained"
                    onClick={() => connectPool()}
                    disabled={isMemberConnectedLoaded && isMemberConnected}
                  >
                    Connect to Pool
                  </Button>
                )}
                {isMemberConnected && (
                  <Button
                    color="error"
                    variant="contained"
                    disabled={isMemberConnectedLoaded && !isMemberConnected}
                    onClick={() => disconnectPool()}
                  >
                    Disconnect from Pool
                  </Button>
                )}
              </div>
            </TabPanel>
          </div>
        )}
      </Paper>

      <footer className={styles.footer}>
        <a href="https://rainbow.me" rel="noopener noreferrer" target="_blank">
          ðŸŒŠ
        </a>
      </footer>
    </Paper>
  );
};

export default Home;
